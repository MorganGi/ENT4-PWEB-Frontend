{"ast":null,"code":"/**\n * Module which splits multi-pag pdfs into single pages\n * Requires the pdftk binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\n\nvar temp = require('temp');\n\nvar exec = require('child_process').exec;\n\nvar fs = require('fs');\n\nvar walk = require('walk');\n\nvar async = require('async');\n\nvar rimraf = require('rimraf');\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @see get_pdfs_in_directory\n * @return {Object} an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output_paths)\n */\n\n\nmodule.exports = function (pdf_path, callback) {\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    var output_dir = temp.path({}, 'pdf_pages');\n    fs.mkdir(output_dir, function (err) {\n      if (err) {\n        return callback(err, null);\n      } // name the files with the upload id and a digit string\n      // example: \"507c3e55c786e2aa6f000005-page00001.pdf\"\n\n\n      var output_name = 'page%05d.pdf\"';\n      var output_path = path.join(output_dir, output_name);\n      var cmd = 'pdftk \"' + pdf_path + '\" burst output \"' + output_path;\n      var child = exec(cmd, function (err, stdout, stderr) {\n        if (err) {\n          var output_err = {\n            message: 'an error occurred while splitting pdf into single pages with the pdftk burst command',\n            error: err\n          };\n          callback(output_err, null);\n          return;\n        }\n\n        remove_doc_data(function (err, reply) {\n          if (err) {\n            return callback(err);\n          }\n\n          return get_pdfs_in_directory(output_dir, callback);\n        });\n      });\n    });\n  });\n};\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Object} output an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output)\n */\n\n\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, {\n    followLinks: false\n  });\n  walker.on('file', function (root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({\n        file_path: file_path,\n        file_name: stat.name\n      });\n    }\n\n    next();\n  });\n  walker.on('end', function () {\n    file_paths.sort(function (a, b) {\n      if (a.file_name < b.file_name) {\n        return -1;\n      }\n\n      if (a.file_name == b.file_name) {\n        return 0;\n      }\n\n      return 1;\n    });\n    var output = {\n      folder: directory_path,\n      files: file_paths\n    };\n    return callback(null, output);\n  });\n}\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\n\n\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n\n    return callback();\n  });\n}\n\n;\n/**\n * pdftk creates a file called doc_data.txt during the burst split process.\n * This file is not needed so remove it now\n */\n\nfunction remove_doc_data(callback) {\n  var folder = path.join(__dirname, '..');\n  var doc_data_path = path.join(folder, 'doc_data.txt');\n  fs.exists(doc_data_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n\n    fs.unlink(doc_data_path, callback);\n  });\n}","map":{"version":3,"names":["path","require","temp","exec","fs","walk","async","rimraf","module","exports","pdf_path","callback","confirm_file_exists","err","output_dir","mkdir","output_name","output_path","join","cmd","child","stdout","stderr","output_err","message","error","remove_doc_data","reply","get_pdfs_in_directory","directory_path","file_paths","files","walker","followLinks","on","root","stat","next","name","match","file_path","push","file_name","sort","a","b","output","folder","exists","__dirname","doc_data_path","unlink"],"sources":["/home/morgan/Desktop/Projets/ENT4/Jwt-Auth-pdf/react-jwt-auth/react-jwt-auth/node_modules/pdf-extract/lib/split.js"],"sourcesContent":["/**\n * Module which splits multi-pag pdfs into single pages\n * Requires the pdftk binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @see get_pdfs_in_directory\n * @return {Object} an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output_paths)\n */\nmodule.exports = function(pdf_path, callback) {\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) { return callback(err); }\n\n    var output_dir = temp.path({},'pdf_pages');\n    fs.mkdir(output_dir, function(err) {\n      if (err) { return callback(err, null); }\n      // name the files with the upload id and a digit string\n      // example: \"507c3e55c786e2aa6f000005-page00001.pdf\"\n      var output_name = 'page%05d.pdf\"';\n      var output_path = path.join(output_dir, output_name);\n      var cmd = 'pdftk \"'+pdf_path+'\" burst output \"'+ output_path;\n      var child = exec(cmd, function (err, stdout, stderr) {\n        if (err) {\n          var output_err = {\n            message: 'an error occurred while splitting pdf into single pages with the pdftk burst command',\n            error: err\n          }\n          callback(output_err, null);\n          return;\n        }\n        remove_doc_data(function (err, reply) {\n          if (err) { return callback(err); }\n          return get_pdfs_in_directory(output_dir, callback);\n        });\n      });\n    });\n  });\n}\n\n\n\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Object} output an object with the fields \"folder\" and \"files\" set\n *   files is an array of the absolute paths to the single page pdf files.\n *\n *   Each entry in this array is an object with fields\n *    <file_name> and <file_path> set\n *\n * @return callback(<maybe error>, output)\n */\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, { followLinks: false});\n  walker.on('file', function(root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({file_path: file_path, file_name: stat.name});\n    }\n    next();\n  });\n\n\n  walker.on('end', function() {\n    file_paths.sort(function (a,b) {\n      if (a.file_name < b.file_name) {\n        return -1;\n      }\n      if (a.file_name == b.file_name) {\n        return 0;\n      }\n      return 1;\n    });\n    var output = {\n      folder: directory_path,\n      files: file_paths\n    }\n    return callback(null, output);\n  });\n}\n\n\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n    return callback();\n  });\n};\n\n/**\n * pdftk creates a file called doc_data.txt during the burst split process.\n * This file is not needed so remove it now\n */\nfunction remove_doc_data(callback) {\n  var folder = path.join(__dirname, '..');\n  var doc_data_path = path.join(folder, 'doc_data.txt');\n  fs.exists(doc_data_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n    fs.unlink(doc_data_path, callback);\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}