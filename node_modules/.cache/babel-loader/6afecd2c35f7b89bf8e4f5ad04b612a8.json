{"ast":null,"code":"var fs = require('fs'),\n    path = require('path'),\n    cnst = require('constants');\n\nvar rimraf = require('rimraf'),\n    os = require('os'),\n    rimrafSync = rimraf.sync;\n/* HELPERS */\n\n\nvar dir = path.resolve(os.tmpdir());\nvar RDWR_EXCL = cnst.O_CREAT | cnst.O_TRUNC | cnst.O_RDWR | cnst.O_EXCL;\n\nvar promisify = function (callback) {\n  if (typeof callback === 'function') {\n    return [undefined, callback];\n  }\n\n  var promiseCallback;\n  var promise = new Promise(function (resolve, reject) {\n    promiseCallback = function () {\n      var args = Array.from(arguments);\n      var err = args.shift();\n      process.nextTick(function () {\n        if (err) {\n          reject(err);\n        } else if (args.length === 1) {\n          resolve(args[0]);\n        } else {\n          resolve(args);\n        }\n      });\n    };\n  });\n  return [promise, promiseCallback];\n};\n\nvar generateName = function (rawAffixes, defaultPrefix) {\n  var affixes = parseAffixes(rawAffixes, defaultPrefix);\n  var now = new Date();\n  var name = [affixes.prefix, now.getFullYear(), now.getMonth(), now.getDate(), '-', process.pid, '-', (Math.random() * 0x100000000 + 1).toString(36), affixes.suffix].join('');\n  return path.join(affixes.dir || dir, name);\n};\n\nvar parseAffixes = function (rawAffixes, defaultPrefix) {\n  var affixes = {\n    prefix: null,\n    suffix: null\n  };\n\n  if (rawAffixes) {\n    switch (typeof rawAffixes) {\n      case 'string':\n        affixes.prefix = rawAffixes;\n        break;\n\n      case 'object':\n        affixes = rawAffixes;\n        break;\n\n      default:\n        throw new Error(\"Unknown affix declaration: \" + affixes);\n    }\n  } else {\n    affixes.prefix = defaultPrefix;\n  }\n\n  return affixes;\n};\n/* -------------------------------------------------------------------------\n * Don't forget to call track() if you want file tracking and exit handlers!\n * -------------------------------------------------------------------------\n * When any temp file or directory is created, it is added to filesToDelete\n * or dirsToDelete. The first time any temp file is created, a listener is\n * added to remove all temp files and directories at exit.\n */\n\n\nvar tracking = false;\n\nvar track = function (value) {\n  tracking = value !== false;\n  return module.exports; // chainable\n};\n\nvar exitListenerAttached = false;\nvar filesToDelete = [];\nvar dirsToDelete = [];\n\nfunction deleteFileOnExit(filePath) {\n  if (!tracking) return false;\n  attachExitListener();\n  filesToDelete.push(filePath);\n}\n\nfunction deleteDirOnExit(dirPath) {\n  if (!tracking) return false;\n  attachExitListener();\n  dirsToDelete.push(dirPath);\n}\n\nfunction attachExitListener() {\n  if (!tracking) return false;\n\n  if (!exitListenerAttached) {\n    process.addListener('exit', cleanupSync);\n    exitListenerAttached = true;\n  }\n}\n\nfunction cleanupFilesSync() {\n  if (!tracking) {\n    return false;\n  }\n\n  var count = 0;\n  var toDelete;\n\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete);\n    count++;\n  }\n\n  return count;\n}\n\nfunction cleanupFiles(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n\n  var count = 0;\n  var left = filesToDelete.length;\n\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n\n  var toDelete;\n\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n\n    if (err) {\n      // This shouldn't happen; pass error to callback and abort\n      // processing\n      callback(err);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n\n    left--;\n\n    if (!left) {\n      callback(null, count);\n    }\n  };\n\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimraf(toDelete, rimrafCallback);\n  }\n\n  return promise;\n}\n\nfunction cleanupDirsSync() {\n  if (!tracking) {\n    return false;\n  }\n\n  var count = 0;\n  var toDelete;\n\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete);\n    count++;\n  }\n\n  return count;\n}\n\nfunction cleanupDirs(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n\n  var count = 0;\n  var left = dirsToDelete.length;\n\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n\n  var toDelete;\n\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n\n    if (err) {\n      // rimraf handles most \"normal\" errors; pass the error to the\n      // callback and abort processing\n      callback(err, count);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n\n    left--;\n\n    if (!left) {\n      callback(null, count);\n    }\n  };\n\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimraf(toDelete, rimrafCallback);\n  }\n\n  return promise;\n}\n\nfunction cleanupSync() {\n  if (!tracking) {\n    return false;\n  }\n\n  var fileCount = cleanupFilesSync();\n  var dirCount = cleanupDirsSync();\n  return {\n    files: fileCount,\n    dirs: dirCount\n  };\n}\n\nfunction cleanup(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n\n  cleanupFiles(function (fileErr, fileCount) {\n    if (fileErr) {\n      callback(fileErr, {\n        files: fileCount\n      });\n    } else {\n      cleanupDirs(function (dirErr, dirCount) {\n        callback(dirErr, {\n          files: fileCount,\n          dirs: dirCount\n        });\n      });\n    }\n  });\n  return promise;\n}\n/* DIRECTORIES */\n\n\nfunction mkdir(affixes, callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n  var dirPath = generateName(affixes, 'd-');\n  fs.mkdir(dirPath, parseInt('0700', 8), function (err) {\n    if (!err) {\n      deleteDirOnExit(dirPath);\n    }\n\n    callback(err, dirPath);\n  });\n  return promise;\n}\n\nfunction mkdirSync(affixes) {\n  var dirPath = generateName(affixes, 'd-');\n  fs.mkdirSync(dirPath, parseInt('0700', 8));\n  deleteDirOnExit(dirPath);\n  return dirPath;\n}\n/* FILES */\n\n\nfunction open(affixes, callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n  var filePath = generateName(affixes, 'f-');\n  fs.open(filePath, RDWR_EXCL, parseInt('0600', 8), function (err, fd) {\n    if (!err) {\n      deleteFileOnExit(filePath);\n    }\n\n    callback(err, {\n      path: filePath,\n      fd: fd\n    });\n  });\n  return promise;\n}\n\nfunction openSync(affixes) {\n  var filePath = generateName(affixes, 'f-');\n  var fd = fs.openSync(filePath, RDWR_EXCL, parseInt('0600', 8));\n  deleteFileOnExit(filePath);\n  return {\n    path: filePath,\n    fd: fd\n  };\n}\n\nfunction createWriteStream(affixes) {\n  var filePath = generateName(affixes, 's-');\n  var stream = fs.createWriteStream(filePath, {\n    flags: RDWR_EXCL,\n    mode: parseInt('0600', 8)\n  });\n  deleteFileOnExit(filePath);\n  return stream;\n}\n/* EXPORTS */\n// Settings\n\n\nexports.dir = dir;\nexports.track = track; // Functions\n\nexports.mkdir = mkdir;\nexports.mkdirSync = mkdirSync;\nexports.open = open;\nexports.openSync = openSync;\nexports.path = generateName;\nexports.cleanup = cleanup;\nexports.cleanupSync = cleanupSync;\nexports.createWriteStream = createWriteStream;","map":{"version":3,"names":["fs","require","path","cnst","rimraf","os","rimrafSync","sync","dir","resolve","tmpdir","RDWR_EXCL","O_CREAT","O_TRUNC","O_RDWR","O_EXCL","promisify","callback","undefined","promiseCallback","promise","Promise","reject","args","Array","from","arguments","err","shift","process","nextTick","length","generateName","rawAffixes","defaultPrefix","affixes","parseAffixes","now","Date","name","prefix","getFullYear","getMonth","getDate","pid","Math","random","toString","suffix","join","Error","tracking","track","value","module","exports","exitListenerAttached","filesToDelete","dirsToDelete","deleteFileOnExit","filePath","attachExitListener","push","deleteDirOnExit","dirPath","addListener","cleanupSync","cleanupFilesSync","count","toDelete","cleanupFiles","p","left","rimrafCallback","cleanupDirsSync","cleanupDirs","fileCount","dirCount","files","dirs","cleanup","fileErr","dirErr","mkdir","parseInt","mkdirSync","open","fd","openSync","createWriteStream","stream","flags","mode"],"sources":["/home/morgan/Desktop/Projets/ENT4/Jwt-Auth-pdf/react-jwt-auth/react-jwt-auth/node_modules/temp/lib/temp.js"],"sourcesContent":["var fs   = require('fs'),\n    path = require('path'),\n    cnst = require('constants');\n\nvar rimraf     = require('rimraf'),\n    os         = require('os'),\n    rimrafSync = rimraf.sync;\n\n/* HELPERS */\n\nvar dir = path.resolve(os.tmpdir());\n\nvar RDWR_EXCL = cnst.O_CREAT | cnst.O_TRUNC | cnst.O_RDWR | cnst.O_EXCL;\n\nvar promisify = function(callback) {\n  if (typeof callback === 'function') {\n    return [undefined, callback];\n  }\n\n  var promiseCallback;\n  var promise = new Promise(function(resolve, reject) {\n    promiseCallback = function() {\n      var args = Array.from(arguments);\n      var err = args.shift();\n\n      process.nextTick(function() {\n        if (err) {\n          reject(err);\n        } else if (args.length === 1) {\n          resolve(args[0]);\n        } else {\n          resolve(args);\n        }\n      });\n    };\n  });\n\n  return [promise, promiseCallback];\n};\n\nvar generateName = function(rawAffixes, defaultPrefix) {\n  var affixes = parseAffixes(rawAffixes, defaultPrefix);\n  var now = new Date();\n  var name = [affixes.prefix,\n              now.getFullYear(), now.getMonth(), now.getDate(),\n              '-',\n              process.pid,\n              '-',\n              (Math.random() * 0x100000000 + 1).toString(36),\n              affixes.suffix].join('');\n  return path.join(affixes.dir || dir, name);\n};\n\nvar parseAffixes = function(rawAffixes, defaultPrefix) {\n  var affixes = {prefix: null, suffix: null};\n  if(rawAffixes) {\n    switch (typeof(rawAffixes)) {\n    case 'string':\n      affixes.prefix = rawAffixes;\n      break;\n    case 'object':\n      affixes = rawAffixes;\n      break;\n    default:\n      throw new Error(\"Unknown affix declaration: \" + affixes);\n    }\n  } else {\n    affixes.prefix = defaultPrefix;\n  }\n  return affixes;\n};\n\n/* -------------------------------------------------------------------------\n * Don't forget to call track() if you want file tracking and exit handlers!\n * -------------------------------------------------------------------------\n * When any temp file or directory is created, it is added to filesToDelete\n * or dirsToDelete. The first time any temp file is created, a listener is\n * added to remove all temp files and directories at exit.\n */\nvar tracking = false;\nvar track = function(value) {\n  tracking = (value !== false);\n  return module.exports; // chainable\n};\nvar exitListenerAttached = false;\nvar filesToDelete = [];\nvar dirsToDelete = [];\n\nfunction deleteFileOnExit(filePath) {\n  if (!tracking) return false;\n  attachExitListener();\n  filesToDelete.push(filePath);\n}\n\nfunction deleteDirOnExit(dirPath) {\n  if (!tracking) return false;\n  attachExitListener();\n  dirsToDelete.push(dirPath);\n}\n\nfunction attachExitListener() {\n  if (!tracking) return false;\n  if (!exitListenerAttached) {\n    process.addListener('exit', cleanupSync);\n    exitListenerAttached = true;\n  }\n}\n\nfunction cleanupFilesSync() {\n  if (!tracking) {\n    return false;\n  }\n  var count = 0;\n  var toDelete;\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete);\n    count++;\n  }\n  return count;\n}\n\nfunction cleanupFiles(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  var count = 0;\n  var left = filesToDelete.length;\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n  var toDelete;\n  var rimrafCallback = function(err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n    if (err) {\n      // This shouldn't happen; pass error to callback and abort\n      // processing\n      callback(err);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n    left--;\n    if (!left) {\n      callback(null, count);\n    }\n  };\n  while ((toDelete = filesToDelete.shift()) !== undefined) {\n    rimraf(toDelete, rimrafCallback);\n  }\n  return promise;\n}\n\nfunction cleanupDirsSync() {\n  if (!tracking) {\n    return false;\n  }\n  var count = 0;\n  var toDelete;\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimrafSync(toDelete);\n    count++;\n  }\n  return count;\n}\n\nfunction cleanupDirs(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  var count = 0;\n  var left = dirsToDelete.length;\n  if (!left) {\n    callback(null, count);\n    return promise;\n  }\n  var toDelete;\n  var rimrafCallback = function (err) {\n    if (!left) {\n      // Prevent processing if aborted\n      return;\n    }\n    if (err) {\n      // rimraf handles most \"normal\" errors; pass the error to the\n      // callback and abort processing\n      callback(err, count);\n      left = 0;\n      return;\n    } else {\n      count++;\n    }\n    left--;\n    if (!left) {\n      callback(null, count);\n    }\n  };\n  while ((toDelete = dirsToDelete.shift()) !== undefined) {\n    rimraf(toDelete, rimrafCallback);\n  }\n  return promise;\n}\n\nfunction cleanupSync() {\n  if (!tracking) {\n    return false;\n  }\n  var fileCount = cleanupFilesSync();\n  var dirCount  = cleanupDirsSync();\n  return {files: fileCount, dirs: dirCount};\n}\n\nfunction cleanup(callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  if (!tracking) {\n    callback(new Error(\"not tracking\"));\n    return promise;\n  }\n  cleanupFiles(function(fileErr, fileCount) {\n    if (fileErr) {\n      callback(fileErr, {files: fileCount});\n    } else {\n      cleanupDirs(function(dirErr, dirCount) {\n        callback(dirErr, {files: fileCount, dirs: dirCount});\n      });\n    }\n  });\n  return promise;\n}\n\n/* DIRECTORIES */\n\nfunction mkdir(affixes, callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  var dirPath = generateName(affixes, 'd-');\n  fs.mkdir(dirPath, parseInt('0700', 8), function(err) {\n    if (!err) {\n      deleteDirOnExit(dirPath);\n    }\n    callback(err, dirPath);\n  });\n  return promise;\n}\n\nfunction mkdirSync(affixes) {\n  var dirPath = generateName(affixes, 'd-');\n  fs.mkdirSync(dirPath, parseInt('0700', 8));\n  deleteDirOnExit(dirPath);\n  return dirPath;\n}\n\n/* FILES */\n\nfunction open(affixes, callback) {\n  var p = promisify(callback);\n  var promise = p[0];\n  callback = p[1];\n\n  var filePath = generateName(affixes, 'f-');\n  fs.open(filePath, RDWR_EXCL, parseInt('0600', 8), function(err, fd) {\n    if (!err) {\n      deleteFileOnExit(filePath);\n    }\n    callback(err, {path: filePath, fd: fd});\n  });\n  return promise;\n}\n\nfunction openSync(affixes) {\n  var filePath = generateName(affixes, 'f-');\n  var fd = fs.openSync(filePath, RDWR_EXCL, parseInt('0600', 8));\n  deleteFileOnExit(filePath);\n  return {path: filePath, fd: fd};\n}\n\nfunction createWriteStream(affixes) {\n  var filePath = generateName(affixes, 's-');\n  var stream = fs.createWriteStream(filePath, {flags: RDWR_EXCL, mode: parseInt('0600', 8)});\n  deleteFileOnExit(filePath);\n  return stream;\n}\n\n/* EXPORTS */\n// Settings\nexports.dir               = dir;\nexports.track             = track;\n// Functions\nexports.mkdir             = mkdir;\nexports.mkdirSync         = mkdirSync;\nexports.open              = open;\nexports.openSync          = openSync;\nexports.path              = generateName;\nexports.cleanup           = cleanup;\nexports.cleanupSync       = cleanupSync;\nexports.createWriteStream = createWriteStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}