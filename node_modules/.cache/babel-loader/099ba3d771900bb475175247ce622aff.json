{"ast":null,"code":"/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar temp = require('temp');\n\nvar path = require('path');\n\nvar exec = require('child_process').exec;\n\nvar fs = require('fs');\n/**\n * @param tif_path path to the single page file on disk containing a scanned image of text\n * @param {Array} options is an optional list of flags to pass to the tesseract command\n * @return {String} extract the extracted ocr text output\n * @return callback(<maybe error>, stdout)\n */\n\n\nmodule.exports = function (input_path, options, callback) {\n  // options is an optional parameter\n  if (!callback || typeof callback != \"function\") {\n    // callback must be the second parameter\n    callback = options;\n    options = [];\n  }\n\n  fs.exists(input_path, function (exists) {\n    if (!exists) {\n      return callback('error, no file exists at the path you specified: ' + input_path);\n    } // get a temp output path\n\n\n    var output_path = temp.path({\n      prefix: 'ocr_output'\n    }); // output_path = path.join(__dirname,'test/test_data/single_page_raw');\n\n    var cmd = 'tesseract \"' + input_path + '\" \"' + output_path + '\" ' + options.join(' ');\n    var child = exec(cmd, function (err, stdout, stderr) {\n      if (err) {\n        return callback(err);\n      } // tesseract automatically appends \".txt\" to the output file name\n\n\n      var text_output_path = output_path + '.txt'; // inspect(text_output_path, 'text output path');\n\n      fs.readFile(text_output_path, 'utf8', function (err, output) {\n        // inspect(output, 'ocr output');\n        if (err) {\n          return callback(err);\n        } // cleanup after ourselves\n\n\n        fs.unlink(text_output_path, function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, output);\n        });\n      });\n    });\n  });\n};","map":{"version":3,"names":["temp","require","path","exec","fs","module","exports","input_path","options","callback","exists","output_path","prefix","cmd","join","child","err","stdout","stderr","text_output_path","readFile","output","unlink"],"sources":["/home/morgan/Desktop/Projets/ENT4/Jwt-Auth-pdf/react-jwt-auth/react-jwt-auth/node_modules/pdf-extract/lib/ocr.js"],"sourcesContent":["/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar temp = require('temp');\nvar path = require('path');\nvar exec = require('child_process').exec;\nvar fs = require('fs');\n\n/**\n * @param tif_path path to the single page file on disk containing a scanned image of text\n * @param {Array} options is an optional list of flags to pass to the tesseract command\n * @return {String} extract the extracted ocr text output\n * @return callback(<maybe error>, stdout)\n */\nmodule.exports = function(input_path, options, callback) {\n  // options is an optional parameter\n  if (!callback || typeof callback != \"function\") {\n    // callback must be the second parameter\n    callback = options;\n    options = [];\n  }\n  fs.exists(input_path, function (exists) {\n    if (!exists) { return callback('error, no file exists at the path you specified: ' + input_path); }\n    // get a temp output path\n    var output_path = temp.path({prefix: 'ocr_output'});\n    // output_path = path.join(__dirname,'test/test_data/single_page_raw');\n    var cmd = 'tesseract \"'+input_path+'\" \"'+output_path+'\" '+options.join(' ');\n    var child = exec(cmd, function (err, stdout, stderr) {\n      if (err) { return callback(err); }\n      // tesseract automatically appends \".txt\" to the output file name\n      var text_output_path = output_path+'.txt';\n      // inspect(text_output_path, 'text output path');\n      fs.readFile(text_output_path, 'utf8', function(err, output) {\n        // inspect(output, 'ocr output');\n        if (err) { return callback(err); }\n        // cleanup after ourselves\n        fs.unlink(text_output_path, function (err) {\n          if (err) { return callback(err); }\n          callback(null, output);\n        });\n      });\n    });\n  });\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,IAAI,GAAGF,OAAO,CAAC,eAAD,CAAP,CAAyBE,IAApC;;AACA,IAAIC,EAAE,GAAGH,OAAO,CAAC,IAAD,CAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACAI,MAAM,CAACC,OAAP,GAAiB,UAASC,UAAT,EAAqBC,OAArB,EAA8BC,QAA9B,EAAwC;EACvD;EACA,IAAI,CAACA,QAAD,IAAa,OAAOA,QAAP,IAAmB,UAApC,EAAgD;IAC9C;IACAA,QAAQ,GAAGD,OAAX;IACAA,OAAO,GAAG,EAAV;EACD;;EACDJ,EAAE,CAACM,MAAH,CAAUH,UAAV,EAAsB,UAAUG,MAAV,EAAkB;IACtC,IAAI,CAACA,MAAL,EAAa;MAAE,OAAOD,QAAQ,CAAC,sDAAsDF,UAAvD,CAAf;IAAoF,CAD7D,CAEtC;;;IACA,IAAII,WAAW,GAAGX,IAAI,CAACE,IAAL,CAAU;MAACU,MAAM,EAAE;IAAT,CAAV,CAAlB,CAHsC,CAItC;;IACA,IAAIC,GAAG,GAAG,gBAAcN,UAAd,GAAyB,KAAzB,GAA+BI,WAA/B,GAA2C,IAA3C,GAAgDH,OAAO,CAACM,IAAR,CAAa,GAAb,CAA1D;IACA,IAAIC,KAAK,GAAGZ,IAAI,CAACU,GAAD,EAAM,UAAUG,GAAV,EAAeC,MAAf,EAAuBC,MAAvB,EAA+B;MACnD,IAAIF,GAAJ,EAAS;QAAE,OAAOP,QAAQ,CAACO,GAAD,CAAf;MAAuB,CADiB,CAEnD;;;MACA,IAAIG,gBAAgB,GAAGR,WAAW,GAAC,MAAnC,CAHmD,CAInD;;MACAP,EAAE,CAACgB,QAAH,CAAYD,gBAAZ,EAA8B,MAA9B,EAAsC,UAASH,GAAT,EAAcK,MAAd,EAAsB;QAC1D;QACA,IAAIL,GAAJ,EAAS;UAAE,OAAOP,QAAQ,CAACO,GAAD,CAAf;QAAuB,CAFwB,CAG1D;;;QACAZ,EAAE,CAACkB,MAAH,CAAUH,gBAAV,EAA4B,UAAUH,GAAV,EAAe;UACzC,IAAIA,GAAJ,EAAS;YAAE,OAAOP,QAAQ,CAACO,GAAD,CAAf;UAAuB;;UAClCP,QAAQ,CAAC,IAAD,EAAOY,MAAP,CAAR;QACD,CAHD;MAID,CARD;IASD,CAde,CAAhB;EAeD,CArBD;AAsBD,CA7BD"},"metadata":{},"sourceType":"script"}