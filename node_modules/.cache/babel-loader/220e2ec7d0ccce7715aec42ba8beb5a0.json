{"ast":null,"code":"/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\n\nvar temp = require('temp');\n\nvar exec = require('child_process').exec;\n\nvar spawn = require('child_process').spawn;\n\nvar fs = require('fs');\n\nvar walk = require('walk');\n\nvar async = require('async');\n\nvar rimraf = require('rimraf');\n/**\n * @param pdf_path path to the single page searchable pdf file on disk\n * This function buffers all the output from stdout and sends it back as a string.\n * Since we only handle single pages of pdf text here the amount of text is small\n * and therefore we don't need to use a stream\n *\n * @return {ReadStream} the entire output from stdout\n * @return callback(<maybe error>, stdout)\n */\n\n\nmodule.exports = function (pdf_path, options, callback) {\n  if (options === undefined) options = {};\n  if (options.layout === undefined) options.layout = true;\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    var child = spawn('pdftotext', (options.layout ? ['-layout'] : []).concat([pdf_path, '-']));\n    var stdout = child.stdout;\n    var stderr = child.stderr;\n    var output = '';\n    stdout.setEncoding('utf8');\n    stderr.setEncoding('utf8');\n    stderr.on('data', function (data) {\n      return callback(data, null);\n    }); // buffer the stdout output\n\n    stdout.on('data', function (data) {\n      output += data;\n    });\n    stdout.on('close', function (data) {\n      return callback(null, output);\n    });\n  });\n};\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Array} files is an array of the absolute paths to the single\n * page pdf files. Each entry in this array is an object with fields\n * <file_name> and <file_path> set\n * @return callback(<maybe error>, files)\n */\n\n\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, {\n    followLinks: false\n  });\n  walker.on('file', function (root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({\n        file_path: file_path,\n        file_name: stat.name\n      });\n      next();\n    }\n  });\n  walker.on('end', function () {\n    return callback(null, file_paths);\n  });\n}\n/**\n * Cleanup any single page pdfs on error\n */\n\n\nfunction cleanup_directory(directory_path, callback) {\n  // only remove the folder at directory_path if it exists\n  fs.exists(directory_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n\n    rimraf(directory_path, callback);\n  });\n}\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\n\n\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n\n    return callback();\n  });\n}\n\n;","map":{"version":3,"names":["path","require","temp","exec","spawn","fs","walk","async","rimraf","module","exports","pdf_path","options","callback","undefined","layout","confirm_file_exists","err","child","concat","stdout","stderr","output","setEncoding","on","data","get_pdfs_in_directory","directory_path","file_paths","files","walker","followLinks","root","stat","next","name","match","file_path","join","push","file_name","cleanup_directory","exists"],"sources":["/home/morgan/Desktop/Projets/ENT4/Jwt-Auth-pdf/react-jwt-auth/react-jwt-auth/node_modules/pdf-extract/lib/searchable.js"],"sourcesContent":["/**\n * Module which extracts text from electronic searchable pdf files.\n * Requires the \"pdftotext\" binary be installed on the system and accessible in the\n * current path\n */\nvar path = require('path');\nvar temp = require('temp');\nvar exec = require('child_process').exec;\nvar spawn = require('child_process').spawn;\nvar fs = require('fs');\nvar walk = require('walk');\nvar async = require('async');\nvar rimraf = require('rimraf');\n\n/**\n * @param pdf_path path to the single page searchable pdf file on disk\n * This function buffers all the output from stdout and sends it back as a string.\n * Since we only handle single pages of pdf text here the amount of text is small\n * and therefore we don't need to use a stream\n *\n * @return {ReadStream} the entire output from stdout\n * @return callback(<maybe error>, stdout)\n */\nmodule.exports = function(pdf_path, options, callback) {\n  if(options===undefined)options={};\n  if(options.layout===undefined)options.layout=true;\n  confirm_file_exists(pdf_path, function (err) {\n    if (err) { return callback(err); }\n    var child = spawn('pdftotext', (options.layout ? ['-layout'] : []).concat([pdf_path, '-']));\n    var stdout = child.stdout;\n    var stderr = child.stderr;\n    var output = '';\n    stdout.setEncoding('utf8');\n    stderr.setEncoding('utf8');\n    stderr.on('data', function(data) {\n      return callback(data, null);\n    });\n    // buffer the stdout output\n    stdout.on('data', function(data) {\n      output += data;\n    });\n    stdout.on('close', function(data) {\n      return callback(null, output);\n    });\n  });\n}\n\n\n/**\n * Non-recursive find of all the files in a given directory that end with *.pdf\n * @return {Array} files is an array of the absolute paths to the single\n * page pdf files. Each entry in this array is an object with fields\n * <file_name> and <file_path> set\n * @return callback(<maybe error>, files)\n */\nfunction get_pdfs_in_directory(directory_path, callback) {\n  var file_paths = [];\n  var files = null;\n  var walker = walk.walk(directory_path, { followLinks: false});\n  walker.on('file', function(root, stat, next) {\n    if (stat.name.match(/\\.pdf$/i)) {\n      var file_path = path.join(directory_path, stat.name);\n      file_paths.push({file_path: file_path, file_name: stat.name});\n      next();\n    }\n  });\n  walker.on('end', function() {\n    return callback(null, file_paths);\n  });\n}\n\n/**\n * Cleanup any single page pdfs on error\n */\nfunction cleanup_directory(directory_path, callback) {\n  // only remove the folder at directory_path if it exists\n  fs.exists(directory_path, function (exists) {\n    if (!exists) {\n      return callback();\n    }\n    rimraf(directory_path, callback);\n  });\n}\n\n/**\n * @param {String} file_path absolute path to file on disk\n * @return {Function} callback() if file does exist\n * callback(<error message>) if file does not exists\n */\nfunction confirm_file_exists(file_path, callback) {\n  fs.exists(file_path, function (exists) {\n    if (!exists) {\n      return callback('no file at path: ' + file_path);\n    }\n    return callback();\n  });\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}