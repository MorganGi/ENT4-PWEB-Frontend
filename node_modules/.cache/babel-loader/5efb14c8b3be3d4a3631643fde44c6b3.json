{"ast":null,"code":"/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n */\nvar fs = require('fs');\n\nvar async = require('async');\n\nvar rimraf = require('rimraf');\n\nvar util = require('util');\n\nvar events = require('events');\n\nvar split = require('./split.js');\n\nvar searchable = require('./searchable.js');\n\nvar pathhash = require('pathhash');\n\nfunction Electronic() {\n  if (false === this instanceof Electronic) {\n    return new Electronic();\n  }\n}\n\nutil.inherits(Electronic, events.EventEmitter);\nmodule.exports = Electronic;\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\n\nElectronic.prototype.process = function (pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  var single_page_pdf_file_paths = [];\n  fs.exists(pdf_path, function (exists) {\n    var err;\n\n    if (!exists) {\n      err = 'no file exists at the path you specified: ' + pdf_path;\n      self.emit('error', {\n        error: err,\n        pdf_path: pdf_path\n      });\n      return;\n    }\n\n    pathhash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', {\n          error: err,\n          pdf_path: pdf_path\n        });\n        return;\n      } // split the pdf into single page pdf files\n\n\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n\n        if (!output) {\n          err = 'failed to split pdf file into distinct pages';\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n\n        split_output = output;\n\n        if (!split_output.hasOwnProperty('files') || split_output.files.length == 0) {\n          err = 'no pages where found in your pdf document';\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        var files = split_output.files;\n        var index = 0;\n        async.forEachSeries(files, // extract the text for each page\n        function (file, cb) {\n          index++;\n          searchable(file.file_path, options, function (err, extract) {\n            if (err) {\n              self.emit('error', {\n                error: err,\n                pdf_path: pdf_path\n              });\n              return;\n            }\n\n            text_pages.push(extract);\n            var file_path = file.file_path;\n            single_page_pdf_file_paths.push(file.file_path);\n            self.emit('page', {\n              hash: hash,\n              text: extract,\n              index: index,\n              pdf_path: pdf_path\n            });\n            cb();\n          });\n        }, function (err) {\n          if (!err) {\n            self.emit('complete', {\n              hash: hash,\n              text_pages: text_pages,\n              pdf_path: pdf_path,\n              single_page_pdf_file_paths: single_page_pdf_file_paths\n            });\n            return;\n          }\n\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n\n          if (!split_output || !split_output.folder) {\n            return;\n          }\n\n          fs.exists(split_output.folder, function (exists) {\n            if (!exists) {\n              return;\n            }\n\n            var remove_cb = function () {};\n\n            rimraf(split_output.folder, remove_cb);\n          });\n        });\n      });\n    });\n  });\n};","map":{"version":3,"names":["fs","require","async","rimraf","util","events","split","searchable","pathhash","Electronic","inherits","EventEmitter","module","exports","prototype","process","pdf_path","options","self","text_pages","split_output","single_page_pdf_file_paths","exists","err","emit","error","hash","output","hasOwnProperty","files","length","index","forEachSeries","file","cb","file_path","extract","push","text","folder","remove_cb"],"sources":["/home/morgan/Desktop/Projets/ENT4/Jwt-Auth-pdf/react-jwt-auth/react-jwt-auth/node_modules/pdf-extract/lib/electronic.js"],"sourcesContent":["/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n */\nvar fs = require('fs');\nvar async = require('async');\n\nvar rimraf = require('rimraf');\nvar util = require('util');\nvar events = require('events');\n\nvar split = require('./split.js');\nvar searchable = require('./searchable.js');\nvar pathhash = require('pathhash');\n\n\nfunction Electronic(){\n  if(false === (this instanceof Electronic)) {\n    return new Electronic();\n  }\n}\nutil.inherits(Electronic, events.EventEmitter);\nmodule.exports = Electronic;\n\n\n/**\n * @param pdf_path path to the pdf file on disk\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\nElectronic.prototype.process = function(pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  var single_page_pdf_file_paths = [];\n  fs.exists(pdf_path, function (exists) {\n    var err;\n    if (!exists) {\n      err = 'no file exists at the path you specified: ' + pdf_path\n      self.emit('error', { error: err, pdf_path: pdf_path});\n      return\n    }\n    pathhash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', { error: err, pdf_path: pdf_path});\n        return\n      }\n      // split the pdf into single page pdf files\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n\n\n        if (!output) {\n          err = 'failed to split pdf file into distinct pages';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        split_output = output;\n        if (!split_output.hasOwnProperty('files') || split_output.files.length == 0) {\n          err = 'no pages where found in your pdf document';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        var files = split_output.files;\n        var index = 0;\n        async.forEachSeries(\n          files,\n          // extract the text for each page\n          function (file, cb) {\n            index++;\n            searchable(file.file_path, options, function (err, extract) {\n\t          if(err){\n\t            self.emit('error', { error: err, pdf_path: pdf_path});\n\t            return;\n\t          }\n              text_pages.push(extract);\n              var file_path = file.file_path\n              single_page_pdf_file_paths.push(file.file_path);\n              self.emit('page', { hash: hash, text: extract, index: index, pdf_path: pdf_path});\n              cb();\n            });\n          },\n          function (err) {\n            if (!err) {\n              self.emit('complete', { hash: hash, text_pages: text_pages, pdf_path: pdf_path, single_page_pdf_file_paths: single_page_pdf_file_paths});\n              return;\n            }\n            self.emit('error', { error: err, pdf_path: pdf_path});\n            if (!split_output || ! split_output.folder) { return }\n            fs.exists(split_output.folder, function (exists) {\n              if (!exists) { return }\n              var remove_cb = function() {}\n              rimraf(split_output.folder, remove_cb);\n            });\n          }\n        );\n      });\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}