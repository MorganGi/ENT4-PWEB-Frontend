{"ast":null,"code":"/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n\n */\nvar util = require('util');\n\nvar events = require('events');\n\nvar fs = require('fs');\n\nvar async = require('async');\n\nvar split = require('./split.js');\n\nvar convert = require('./convert.js');\n\nvar pathHash = require('pathhash');\n\nvar ocr = require('./ocr.js');\n\nvar rimraf = require('rimraf');\n\nfunction Raw() {\n  if (false === this instanceof Raw) {\n    return new Raw();\n  }\n}\n\nutil.inherits(Raw, events.EventEmitter);\nmodule.exports = Raw;\n/**\n * @param {String} pdf_path path to the pdf file on disk\n * @param {Boolean} params.clean true to remove the temporary single-page pdf\n *   files from disk. Sometimes however you might want to be able to use those\n *   single page pdfs after the ocr completes. In this case pass clean = false\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\n\nRaw.prototype.process = function (pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n\n  if (!options) {\n    options = {};\n  } // default to removing the single page pdfs after ocr completes\n\n\n  if (!options.hasOwnProperty('clean')) {\n    options.clean = true;\n  }\n\n  fs.exists(pdf_path, function (exists) {\n    if (!exists) {\n      var err = 'no file exists at the path you specified: ' + pdf_path;\n      self.emit('error', {\n        error: err,\n        pdf_path: pdf_path\n      });\n      return;\n    }\n\n    pathHash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', {\n          error: err,\n          pdf_path: pdf_path\n        });\n        return;\n      }\n\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n\n        if (!output) {\n          err = 'no files returned from split';\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        split_output = output;\n        var pdf_files = output.files;\n\n        if (!pdf_files || pdf_files.length == 0) {\n          err = 'error, no pages where found in your pdf document';\n          self.emit('error', {\n            error: err,\n            pdf_path: pdf_path\n          });\n          return;\n        }\n\n        var index = 0;\n        var num_pages = pdf_files.length;\n        var single_page_pdf_file_paths = [];\n        async.forEachSeries(pdf_files, // extract the text for each page via ocr\n        function (pdf_file, cb) {\n          var quality = 300;\n\n          if (options.hasOwnProperty('quality') && options.quality) {\n            quality = options.quality;\n          }\n\n          convert(pdf_file.file_path, quality, function (err, tif_path) {\n            var zeroBasedNumPages = num_pages - 1;\n            self.emit('log', 'converted page to intermediate tiff file, page ' + index + ' (0-based indexing) of ' + zeroBasedNumPages);\n\n            if (err) {\n              return cb(err);\n            }\n\n            var ocr_flags = ['-psm 6'];\n\n            if (options.ocr_flags) {\n              ocr_flags = options.ocr_flags;\n            }\n\n            ocr(tif_path, ocr_flags, function (err, extract) {\n              fs.unlink(tif_path, function (tif_cleanup_err, reply) {\n                if (tif_cleanup_err) {\n                  err += ', error removing temporary tif file: \"' + tif_cleanup_err + '\"';\n                }\n\n                if (err) {\n                  return cb(err);\n                }\n\n                var page_number = index + 1;\n                self.emit('log', 'raw ocr: page ' + index + ' (0-based indexing) of ' + zeroBasedNumPages + ' complete');\n                single_page_pdf_file_paths.push(pdf_file.file_path);\n                self.emit('page', {\n                  hash: hash,\n                  text: extract,\n                  index: index,\n                  num_pages: num_pages,\n                  pdf_path: pdf_path,\n                  single_page_pdf_path: pdf_file.file_path\n                });\n                text_pages.push(extract);\n                index++;\n                cb();\n              });\n            });\n          });\n        }, function (err) {\n          if (err) {\n            self.emit('error', err);\n            return;\n          }\n\n          self.emit('complete', {\n            hash: hash,\n            text_pages: text_pages,\n            pdf_path: pdf_path,\n            single_page_pdf_file_paths: single_page_pdf_file_paths\n          });\n        });\n      });\n    });\n  });\n};","map":{"version":3,"names":["util","require","events","fs","async","split","convert","pathHash","ocr","rimraf","Raw","inherits","EventEmitter","module","exports","prototype","process","pdf_path","options","self","text_pages","split_output","hasOwnProperty","clean","exists","err","emit","error","hash","output","pdf_files","files","length","index","num_pages","single_page_pdf_file_paths","forEachSeries","pdf_file","cb","quality","file_path","tif_path","zeroBasedNumPages","ocr_flags","extract","unlink","tif_cleanup_err","reply","page_number","push","text","single_page_pdf_path"],"sources":["/home/morgan/Desktop/Projets/ENT4/Jwt-Auth-pdf/react-jwt-auth/react-jwt-auth/node_modules/pdf-extract/lib/raw.js"],"sourcesContent":["/**\n * Module which extracts the text out of an electronic pdf file\n * This module can handle multi-page pdf files\n\n */\nvar util = require('util');\nvar events = require('events');\nvar fs = require('fs');\nvar async = require('async');\nvar split = require('./split.js');\nvar convert = require('./convert.js');\nvar pathHash = require('pathhash');\nvar ocr = require('./ocr.js');\nvar rimraf = require('rimraf');\n\n\nfunction Raw(){\n  if(false === (this instanceof Raw)) {\n    return new Raw();\n  }\n}\nutil.inherits(Raw, events.EventEmitter);\nmodule.exports = Raw;\n\n\n/**\n * @param {String} pdf_path path to the pdf file on disk\n * @param {Boolean} params.clean true to remove the temporary single-page pdf\n *   files from disk. Sometimes however you might want to be able to use those\n *   single page pdfs after the ocr completes. In this case pass clean = false\n *\n * @return {Array} text_pages an array of the extracted text where\n *   each entry is the text for the page at the given index\n * @return callback(<maybe error>, text_pages)\n */\nRaw.prototype.process = function(pdf_path, options) {\n  var self = this;\n  var text_pages = [];\n  var split_output;\n  if (!options) {\n    options = {};\n  }\n  // default to removing the single page pdfs after ocr completes\n  if (!options.hasOwnProperty('clean')) {\n    options.clean = true;\n  }\n  fs.exists(pdf_path, function (exists) {\n    if (!exists) {\n      var err = 'no file exists at the path you specified: ' + pdf_path\n      self.emit('error', { error: err, pdf_path: pdf_path});\n      return\n    }\n    pathHash(pdf_path, function (err, hash) {\n      if (err) {\n        err = 'error hashing file at the path you specified: ' + pdf_path + '. ' + err;\n        self.emit('error', { error: err, pdf_path: pdf_path});\n        return;\n      }\n      split(pdf_path, function (err, output) {\n        if (err) {\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return\n        }\n        if (!output) {\n          err = 'no files returned from split';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return;\n        }\n        self.emit('log', 'finished splitting pages for file at path ' + pdf_path);\n        split_output = output;\n        var pdf_files = output.files;\n        if (!pdf_files || pdf_files.length == 0) {\n          err = 'error, no pages where found in your pdf document';\n          self.emit('error', { error: err, pdf_path: pdf_path});\n          return;\n        }\n        var index = 0;\n        var num_pages = pdf_files.length\n        var single_page_pdf_file_paths = [];\n        async.forEachSeries(\n          pdf_files,\n          // extract the text for each page via ocr\n          function (pdf_file, cb) {\n            var quality = 300;\n            if (options.hasOwnProperty('quality') && options.quality) {\n              quality = options.quality;\n            }\n            convert(pdf_file.file_path, quality, function (err, tif_path) {\n              var zeroBasedNumPages = num_pages-1;\n              self.emit('log', 'converted page to intermediate tiff file, page '+ index+ ' (0-based indexing) of '+ zeroBasedNumPages);\n              if (err) { return cb(err); }\n              var ocr_flags = [\n                '-psm 6'\n              ];\n              if (options.ocr_flags) {\n                ocr_flags = options.ocr_flags;\n              }\n              ocr(tif_path, ocr_flags, function (err, extract) {\n                fs.unlink(tif_path, function (tif_cleanup_err, reply) {\n                  if (tif_cleanup_err) {\n                    err += ', error removing temporary tif file: \"'+tif_cleanup_err+'\"';\n                  }\n                  if (err) { return cb(err); }\n                  var page_number = index+1\n                  self.emit('log', 'raw ocr: page ' + index + ' (0-based indexing) of ' +zeroBasedNumPages + ' complete');\n                  single_page_pdf_file_paths.push(pdf_file.file_path);\n                  self.emit('page', { hash: hash, text: extract, index: index, num_pages: num_pages, pdf_path: pdf_path, single_page_pdf_path: pdf_file.file_path});\n                  text_pages.push(extract);\n                  index++;\n                  cb();\n                });\n              });\n            });\n          }, function (err) {\n            if (err) {\n              self.emit('error', err);\n              return;\n            }\n            self.emit('complete', { hash: hash, text_pages: text_pages, pdf_path: pdf_path, single_page_pdf_file_paths: single_page_pdf_file_paths});\n          });\n      });\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}