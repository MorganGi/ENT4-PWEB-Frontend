{"ast":null,"code":"import { PathElement, Rect, Point, Size, RotateTransform, TextElement, randomId, identityMatrix, rotateMatrix, transformPointByMatrix, intersect3 } from '@syncfusion/ej2-drawings';\nimport { setElementStype, findPointsLength } from './drawing-util';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {PointModel[]} - Returns the annotation points model array.\n */\n\nexport function getConnectorPoints(obj, points) {\n  points = obj.vertexPoints;\n  var newPoints = points.slice(0);\n\n  if (newPoints && newPoints.length > 0) {\n    obj.sourcePoint = newPoints[0];\n    obj.targetPoint = newPoints[newPoints.length - 1];\n  }\n\n  return newPoints;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {string} - Returns the annotation path value.\n */\n\nexport function getSegmentPath(connector, points) {\n  var path = '';\n  var getPt;\n  var pts = [];\n  var j = 0;\n\n  while (j < points.length) {\n    pts.push({\n      x: points[j].x,\n      y: points[j].y\n    });\n    j++;\n  }\n\n  pts = clipDecorators(connector, pts);\n\n  for (var k = 0; k < pts.length; k++) {\n    getPt = pts[k];\n\n    if (k === 0) {\n      path = 'M' + getPt.x + ' ' + getPt.y;\n    }\n\n    if (k > 0) {\n      path += ' ' + 'L' + getPt.x + ' ' + getPt.y;\n    }\n  }\n\n  return path;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @param {PathElement} element - Specified the annotation element.\n * @returns {PathElement} - Returns the annotation path element.\n */\n\nexport function updateSegmentElement(connector, points, element) {\n  var bounds = new Rect();\n  var segmentPath = getSegmentPath(connector, points);\n  bounds = Rect.toBounds(points);\n  element.width = bounds.width;\n  element.height = bounds.height;\n  element.offsetX = bounds.x + element.width / 2;\n  element.offsetY = bounds.y + element.height / 2;\n  element.data = segmentPath;\n\n  if (connector.wrapper) {\n    connector.wrapper.offsetX = element.offsetX;\n    connector.wrapper.offsetY = element.offsetY;\n    connector.wrapper.width = bounds.width;\n    connector.wrapper.height = bounds.height;\n  }\n\n  return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PathElement} segmentElement - Specified the annotation segment element.\n * @returns {PathElement} - Returns the annotation path element.\n */\n\nexport function getSegmentElement(connector, segmentElement) {\n  var points = [];\n  points = getConnectorPoints(connector);\n  segmentElement.staticSize = true;\n  segmentElement = updateSegmentElement(connector, points, segmentElement);\n  setElementStype(connector, segmentElement);\n  return segmentElement;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {DrawingElement} element - Specified the annotation drawing element.\n * @param {PointModel} pt - Specified the annotation point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {void}\n */\n\nexport function updateDecoratorElement(obj, element, pt, adjacentPoint, isSource) {\n  element.offsetX = pt.x;\n  element.offsetY = pt.y;\n  var angle = Point.findAngle(pt, adjacentPoint);\n  var getPath = getDecoratorShape(isSource ? obj.sourceDecoraterShapes : obj.taregetDecoraterShapes);\n  var thickness = 0;\n  var size;\n\n  if (obj.shapeAnnotationType === 'LineWidthArrowHead') {\n    thickness = obj.thickness;\n    size = new Size(thickness * 12, thickness * 12);\n  } else {\n    thickness = obj.thickness <= 5 ? 5 : obj.thickness;\n    size = new Size(thickness * 2, thickness * 2);\n  }\n\n  element.transform = RotateTransform.Self;\n  setElementStype(obj, element);\n  element.style.fill = obj.fillColor !== 'tranparent' ? obj.fillColor : 'white';\n  element.rotateAngle = angle;\n  element.data = getPath;\n  element.canMeasurePath = true;\n  element.width = size.width;\n  element.height = size.height;\n\n  if (obj.sourceDecoraterShapes === 'Butt') {\n    element.width = size.width - 10;\n    element.height = size.height + 10;\n  }\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} offsetPoint - Specified the annotation offset point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PathElement} - Returns the annotation path element.\n */\n\nexport function getDecoratorElement(obj, offsetPoint, adjacentPoint, isSource) {\n  var decEle = new PathElement();\n  updateDecoratorElement(obj, decEle, offsetPoint, adjacentPoint, isSource);\n  return decEle;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation object.\n * @param {PointModel[]} pts - Specified the annotation point model array.\n * @returns {PointModel[]} - Returns the annotation point model array.\n */\n\nexport function clipDecorators(connector, pts) {\n  pts[0] = clipDecorator(connector, pts, true);\n  pts[pts.length - 1] = clipDecorator(connector, pts, false);\n  return pts;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel[]} points - Specified the annotation offset point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PointModel} - Returns the annotation point model.\n */\n\nexport function clipDecorator(connector, points, isSource) {\n  var point = {\n    x: 0,\n    y: 0\n  };\n  var start = {\n    x: 0,\n    y: 0\n  };\n  var end = {\n    x: 0,\n    y: 0\n  };\n  var length = points.length;\n  start = !isSource ? points[length - 1] : points[0];\n  end = !isSource ? points[length - 2] : points[1];\n  var len = Point.distancePoints(start, end);\n  len = len === 0 ? 1 : len;\n  var width = connector.thickness;\n  point.x = Math.round(start.x + width * (end.x - start.x) / len);\n  point.y = Math.round(start.y + width * (end.y - start.y) / len);\n  var strokeWidth = 1;\n  point = Point.adjustPoint(point, end, true, strokeWidth / 2);\n  return point;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\n// eslint-disable-next-line max-len\n\nexport function initDistanceLabel(obj, points, measure, pdfviewer) {\n  var labels = [];\n  var angle = Point.findAngle(points[0], points[1]);\n  var textele = textElement(obj, angle);\n\n  if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n    textele.content = obj.notes;\n  } else {\n    textele.content = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n  }\n\n  textele.rotateValue = {\n    y: -10,\n    angle: angle\n  };\n\n  if (obj.enableShapeLabel === true) {\n    textele.style.strokeColor = obj.labelBorderColor;\n    textele.style.fill = obj.labelFillColor;\n    textele.style.fontSize = obj.fontSize;\n    textele.style.color = obj.fontColor;\n    textele.style.fontFamily = obj.fontFamily;\n  }\n\n  labels.push(textele);\n  return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the distance value.\n */\n\nexport function updateDistanceLabel(obj, points, measure) {\n  var distance;\n\n  for (var i = 0; i < obj.wrapper.children.length; i++) {\n    var textElement_1 = obj.wrapper.children[i];\n\n    if (textElement_1 && !isNullOrUndefined(textElement_1.content)) {\n      distance = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n      textElement_1.content = distance;\n      textElement_1.childNodes[0].text = textElement_1.content;\n      textElement_1.refreshTextElement();\n    }\n  }\n\n  return distance;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the radius label value.\n */\n\nexport function updateRadiusLabel(obj, measure) {\n  var radius;\n\n  for (var i = 0; i < obj.wrapper.children.length; i++) {\n    var textElement_2 = obj.wrapper.children[i];\n\n    if (textElement_2 && !isNullOrUndefined(textElement_2.content)) {\n      radius = measure.setConversion(obj.bounds.width / 2 * measure.pixelToPointFactor, obj);\n      textElement_2.content = radius;\n\n      if (textElement_2.childNodes.length === 2) {\n        textElement_2.childNodes[0].text = radius;\n        textElement_2.childNodes.splice(textElement_2.childNodes.length - 1, 1);\n      } else {\n        textElement_2.childNodes[0].text = radius;\n      }\n\n      textElement_2.refreshTextElement();\n    }\n  }\n\n  return radius;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\n// eslint-disable-next-line max-len\n\nexport function initPerimeterLabel(obj, points, measure, pdfviewer) {\n  var labels = [];\n  var angle = Point.findAngle(points[0], points[1]);\n  var textele = textElement(obj, angle);\n\n  if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n    textele.content = obj.notes;\n  } else {\n    textele.content = measure.calculatePerimeter(obj);\n  }\n\n  if (obj.enableShapeLabel === true) {\n    textele.style.strokeColor = obj.labelBorderColor;\n    textele.style.fill = obj.labelFillColor;\n    textele.style.fontSize = obj.fontSize;\n    textele.style.color = obj.fontColor;\n    textele.style.fontFamily = obj.fontFamily;\n  }\n\n  textele.rotateValue = {\n    y: -10,\n    angle: angle\n  };\n  labels.push(textele);\n  return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the perimeter label value.\n */\n\nexport function updatePerimeterLabel(obj, points, measure) {\n  var perimeter;\n\n  for (var i = 0; i < obj.wrapper.children.length; i++) {\n    var textElement_3 = obj.wrapper.children[i];\n\n    if (textElement_3 && !isNullOrUndefined(textElement_3.content)) {\n      perimeter = measure.calculatePerimeter(obj);\n      textElement_3.content = perimeter;\n      textElement_3.childNodes[0].text = textElement_3.content;\n      textElement_3.refreshTextElement();\n    }\n  }\n\n  return perimeter;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\n\nexport function removePerimeterLabel(obj) {\n  for (var i = 0; i < obj.wrapper.children.length; i++) {\n    var textElement_4 = obj.wrapper.children[i];\n\n    if (textElement_4 && !isNullOrUndefined(textElement_4.content)) {\n      obj.wrapper.children.splice(i, 1);\n    }\n  }\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\n\nexport function updateCalibrateLabel(obj) {\n  if (obj.wrapper && obj.wrapper.children) {\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n      var textElement_5 = obj.wrapper.children[i];\n\n      if (textElement_5 && !isNullOrUndefined(textElement_5.content)) {\n        textElement_5.content = obj.notes;\n        textElement_5.childNodes[0].text = textElement_5.content;\n        textElement_5.refreshTextElement();\n      }\n    }\n  }\n}\n/**\n * Used to find the path for polygon shapes\n *\n * @param {PointModel[]} collection - Specified the polygon annotaion points collection.\n * @hidden\n * @returns {string} - Returns the polygon annotation path.\n */\n\nexport function getPolygonPath(collection) {\n  var path = '';\n  var seg;\n  path = 'M' + collection[0].x + ' ' + collection[0].y;\n  var i;\n\n  for (i = 1; i < collection.length; i++) {\n    seg = collection[i];\n    path += 'L' + seg.x + ' ' + seg.y;\n  }\n\n  path += 'Z';\n  return path;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {number} angle - Specified the annotaion rotation angle.\n * @hidden\n * @returns {TextElement} - Returns the annotation text element.\n */\n\nexport function textElement(obj, angle) {\n  var textele = new TextElement();\n  setElementStype(obj, textele);\n  textele.style.fill = 'transparent';\n  textele.id = randomId();\n  textele.horizontalAlignment = 'Center';\n  textele.rotateValue = {\n    y: 10,\n    angle: angle\n  };\n  textele.verticalAlignment = 'Top';\n  textele.relativeMode = 'Object';\n  textele.setOffsetWithRespectToBounds(.5, .5, 'Absolute'); // eslint-disable-next-line\n\n  textele.offsetX;\n  textele.style.textWrapping = 'NoWrap';\n  return textele;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotaion leader points.\n * @hidden\n * @returns {PathElement[]} - Returns the annotation path elements.\n */\n\nexport function initLeaders(obj, points) {\n  var leaders = [];\n  var leader = initLeader(obj, points[0], points[1]);\n  leaders.push(leader);\n  leader = initLeader(obj, points[1], points[0], true);\n  leaders.push(leader);\n  return leaders;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} point1 - Specified the annotaion leader point1.\n * @param {PointModel} point2 - Specified the annotaion leader point2.\n * @param {boolean} isSecondLeader - Specified the is second leader or not.\n * @hidden\n * @returns {PathElement} - Returns the annotation path element.\n */\n\nexport function initLeader(obj, point1, point2, isSecondLeader) {\n  var element = new PathElement();\n  element.offsetX = point1.x;\n  element.offsetY = point1.y;\n  var angle = Point.findAngle(point1, point2);\n  var center = {\n    x: (point1.x + point2.x) / 2,\n    y: (point1.y + point2.y) / 2\n  };\n  var matrix = identityMatrix();\n  rotateMatrix(matrix, 0 - angle, center.x, center.y);\n  var rotatedPoint = transformPointByMatrix(matrix, point1);\n  var newPoint1 = {\n    x: rotatedPoint.x,\n    y: rotatedPoint.y - obj.leaderHeight\n  };\n  matrix = identityMatrix();\n  rotateMatrix(matrix, angle, element.offsetX, element.offsetY);\n  rotatedPoint = transformPointByMatrix(matrix, newPoint1);\n  var finalPoint = {\n    x: point1.x,\n    y: point1.y\n  };\n  element.offsetX = finalPoint.x;\n  element.offsetY = finalPoint.y;\n  element.transform = RotateTransform.Self;\n  var getPath = 'M' + point1.x + ',' + point1.y + ',L' + rotatedPoint.x + ',' + rotatedPoint.y + 'Z';\n  var size = new Size(0, obj.leaderHeight);\n  element.pivot.x = .5;\n\n  if (isSecondLeader) {\n    element.id = 'leader2_' + randomId();\n    element.pivot.y = 0;\n  } else {\n    element.id = 'leader1_' + randomId();\n    element.pivot.y = 1;\n  }\n\n  setElementStype(obj, element);\n  element.rotateAngle = angle;\n  element.data = getPath;\n  element.canMeasurePath = true;\n  element.width = size.width;\n  element.height = size.height;\n  return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel} reference - Specified the pointer reference value.\n * @returns {boolean} - Returns true or false.\n */\n\nexport function isPointOverConnector(connector, reference) {\n  var vertexPoints = connector.vertexPoints;\n\n  if (!isNullOrUndefined(vertexPoints)) {\n    for (var i = 0; i < vertexPoints.length - 1; i++) {\n      var start = vertexPoints[i];\n      var end = vertexPoints[i + 1];\n      var rect = Rect.toBounds([start, end]);\n      rect.Inflate(10);\n\n      if (rect.containsPoint(reference)) {\n        var intersectinPt = findNearestPoint(reference, start, end);\n        var segment1 = {\n          x1: start.x,\n          x2: end.x,\n          y1: start.y,\n          y2: end.y\n        };\n        var segment2 = {\n          x1: reference.x,\n          x2: intersectinPt.x,\n          y1: reference.y,\n          y2: intersectinPt.y\n        };\n        var intersectDetails = intersect3(segment1, segment2);\n\n        if (intersectDetails.enabled) {\n          var distance = Point.findLength(reference, intersectDetails.intersectPt);\n\n          if (Math.abs(distance) < 10) {\n            return true;\n          }\n        } else {\n          var rect_1 = Rect.toBounds([reference, reference]);\n          rect_1.Inflate(3);\n\n          if (rect_1.containsPoint(start) || rect_1.containsPoint(end)) {\n            return true;\n          }\n        }\n\n        if (Point.equals(reference, intersectinPt)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * @param {PointModel} reference - Specified the pointer reference value.\n * @param {PointModel} start - Specified the pointer start value.\n * @param {PointModel} end - Specified the pointer end value.\n * @private\n * @returns {PointModel} - Returns annotation point model.\n */\n\nexport function findNearestPoint(reference, start, end) {\n  var shortestPoint;\n  var shortest = Point.findLength(start, reference);\n  var shortest1 = Point.findLength(end, reference);\n\n  if (shortest > shortest1) {\n    shortestPoint = end;\n  } else {\n    shortestPoint = start;\n  }\n\n  var angleBWStAndEnd = Point.findAngle(start, end);\n  var angleBWStAndRef = Point.findAngle(shortestPoint, reference);\n  var r = Point.findLength(shortestPoint, reference);\n  var vaAngle = angleBWStAndRef + (angleBWStAndEnd - angleBWStAndRef) * 2;\n  return {\n    x: shortestPoint.x + r * Math.cos(vaAngle * Math.PI / 180),\n    y: shortestPoint.y + r * Math.sin(vaAngle * Math.PI / 180)\n  };\n}\n/**\n * @param {DecoratorShapes} shape - Specified the annotation decorator shapes.\n * @hidden\n * @returns {string} - Returns the annotation decorator shape value.\n */\n\nexport function getDecoratorShape(shape) {\n  // eslint-disable-next-line\n  return decoratorShapes[shape];\n}\nvar decoratorShapes = {\n  'OpenArrow': 'M15.9,23 L5,16 L15.9,9 L17,10.7 L8.7,16 L17,21.3Z',\n  'Square': 'M0,0 L10,0 L10,10 L0,10 z',\n  'Fletch': 'M14.8,10c0,0-3.5,6,0.2,12c0,0-2.5-6-10.9-6C4.1,16,11.3,16,14.8,10z',\n  'OpenFetch': 'M6,17c-0.6,0-1-0.4-1-1s0.4-1,1-1c10.9,0,11-5,11-5' + 'c0-0.6,0.4-1,1-1s1,0.4,1,1C19,10.3,18.9,17,6,17C6,17,6,17,6,17z ' + 'M18,23c-0.5,0-1-0.4-1-1c0-0.2-0.3-5-11-5c-0.6,0-1-0.5-1-1s0.4-1,1-1c0,0,0,0,0,0' + 'c12.9,0,13,6.7,13,7    C19,22.6,18.6,23,18,23z',\n  'IndentedArrow': 'M17,10c0,0-4.5,5.5,0,12L5,16L17,10z',\n  'OutdentedArrow': 'M14.6,10c0,0,5.4,6,0,12L5,16L14.6,10z',\n  'DoubleArrow': 'M19,10 L19,22 L13,16Z M12,10 L12,22 L6,16Z',\n  'Arrow': 'M15,10 L15,22 L5,16Z',\n  'Diamond': 'M12,23l-7-7l7-7l6.9,7L12,23z',\n  'Circle': 'M0,50 A50,50,0 1 1 100,50 A50,50,0 1 1 0,50 Z',\n  'Butt': 'M0,0 L0,90'\n};","map":{"version":3,"names":["PathElement","Rect","Point","Size","RotateTransform","TextElement","randomId","identityMatrix","rotateMatrix","transformPointByMatrix","intersect3","setElementStype","findPointsLength","isNullOrUndefined","getConnectorPoints","obj","points","vertexPoints","newPoints","slice","length","sourcePoint","targetPoint","getSegmentPath","connector","path","getPt","pts","j","push","x","y","clipDecorators","k","updateSegmentElement","element","bounds","segmentPath","toBounds","width","height","offsetX","offsetY","data","wrapper","getSegmentElement","segmentElement","staticSize","updateDecoratorElement","pt","adjacentPoint","isSource","angle","findAngle","getPath","getDecoratorShape","sourceDecoraterShapes","taregetDecoraterShapes","thickness","size","shapeAnnotationType","transform","Self","style","fill","fillColor","rotateAngle","canMeasurePath","getDecoratorElement","offsetPoint","decEle","clipDecorator","point","start","end","len","distancePoints","Math","round","strokeWidth","adjustPoint","initDistanceLabel","measure","pdfviewer","labels","textele","textElement","enableImportAnnotationMeasurement","notes","content","setConversion","pixelToPointFactor","rotateValue","enableShapeLabel","strokeColor","labelBorderColor","labelFillColor","fontSize","color","fontColor","fontFamily","updateDistanceLabel","distance","i","children","textElement_1","childNodes","text","refreshTextElement","updateRadiusLabel","radius","textElement_2","splice","initPerimeterLabel","calculatePerimeter","updatePerimeterLabel","perimeter","textElement_3","removePerimeterLabel","textElement_4","updateCalibrateLabel","textElement_5","getPolygonPath","collection","seg","id","horizontalAlignment","verticalAlignment","relativeMode","setOffsetWithRespectToBounds","textWrapping","initLeaders","leaders","leader","initLeader","point1","point2","isSecondLeader","center","matrix","rotatedPoint","newPoint1","leaderHeight","finalPoint","pivot","isPointOverConnector","reference","rect","Inflate","containsPoint","intersectinPt","findNearestPoint","segment1","x1","x2","y1","y2","segment2","intersectDetails","enabled","findLength","intersectPt","abs","rect_1","equals","shortestPoint","shortest","shortest1","angleBWStAndEnd","angleBWStAndRef","r","vaAngle","cos","PI","sin","shape","decoratorShapes"],"sources":["/home/morgan/Desktop/Projets/ENT4/Jwt-Auth-pdf/react-jwt-auth/react-jwt-auth/node_modules/@syncfusion/ej2-pdfviewer/src/pdfviewer/drawing/connector-util.js"],"sourcesContent":["import { PathElement, Rect, Point, Size, RotateTransform, TextElement, randomId, identityMatrix, rotateMatrix, transformPointByMatrix, intersect3 } from '@syncfusion/ej2-drawings';\nimport { setElementStype, findPointsLength } from './drawing-util';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {PointModel[]} - Returns the annotation points model array.\n */\nexport function getConnectorPoints(obj, points) {\n    points = obj.vertexPoints;\n    var newPoints = points.slice(0);\n    if (newPoints && newPoints.length > 0) {\n        obj.sourcePoint = newPoints[0];\n        obj.targetPoint = newPoints[newPoints.length - 1];\n    }\n    return newPoints;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @returns {string} - Returns the annotation path value.\n */\nexport function getSegmentPath(connector, points) {\n    var path = '';\n    var getPt;\n    var pts = [];\n    var j = 0;\n    while (j < points.length) {\n        pts.push({ x: points[j].x, y: points[j].y });\n        j++;\n    }\n    pts = clipDecorators(connector, pts);\n    for (var k = 0; k < pts.length; k++) {\n        getPt = pts[k];\n        if (k === 0) {\n            path = 'M' + getPt.x + ' ' + getPt.y;\n        }\n        if (k > 0) {\n            path += ' ' + 'L' + getPt.x + ' ' + getPt.y;\n        }\n    }\n    return path;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PointModel[]} points - Specified the annotation points.\n * @param {PathElement} element - Specified the annotation element.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function updateSegmentElement(connector, points, element) {\n    var bounds = new Rect();\n    var segmentPath = getSegmentPath(connector, points);\n    bounds = Rect.toBounds(points);\n    element.width = bounds.width;\n    element.height = bounds.height;\n    element.offsetX = bounds.x + element.width / 2;\n    element.offsetY = bounds.y + element.height / 2;\n    element.data = segmentPath;\n    if (connector.wrapper) {\n        connector.wrapper.offsetX = element.offsetX;\n        connector.wrapper.offsetY = element.offsetY;\n        connector.wrapper.width = bounds.width;\n        connector.wrapper.height = bounds.height;\n    }\n    return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector model.\n * @param {PathElement} segmentElement - Specified the annotation segment element.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function getSegmentElement(connector, segmentElement) {\n    var points = [];\n    points = getConnectorPoints(connector);\n    segmentElement.staticSize = true;\n    segmentElement = updateSegmentElement(connector, points, segmentElement);\n    setElementStype(connector, segmentElement);\n    return segmentElement;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {DrawingElement} element - Specified the annotation drawing element.\n * @param {PointModel} pt - Specified the annotation point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {void}\n */\nexport function updateDecoratorElement(obj, element, pt, adjacentPoint, isSource) {\n    element.offsetX = pt.x;\n    element.offsetY = pt.y;\n    var angle = Point.findAngle(pt, adjacentPoint);\n    var getPath = getDecoratorShape(isSource ? obj.sourceDecoraterShapes : obj.taregetDecoraterShapes);\n    var thickness = 0;\n    var size;\n    if (obj.shapeAnnotationType === 'LineWidthArrowHead') {\n        thickness = obj.thickness;\n        size = new Size(thickness * 12, thickness * 12);\n    }\n    else {\n        thickness = obj.thickness <= 5 ? 5 : obj.thickness;\n        size = new Size(thickness * 2, thickness * 2);\n    }\n    element.transform = RotateTransform.Self;\n    setElementStype(obj, element);\n    element.style.fill = (obj.fillColor !== 'tranparent') ? obj.fillColor : 'white';\n    element.rotateAngle = angle;\n    element.data = getPath;\n    element.canMeasurePath = true;\n    element.width = size.width;\n    element.height = size.height;\n    if (obj.sourceDecoraterShapes === 'Butt') {\n        element.width = size.width - 10;\n        element.height = size.height + 10;\n    }\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} offsetPoint - Specified the annotation offset point.\n * @param {PointModel} adjacentPoint - Specified the annotation adjacent point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function getDecoratorElement(obj, offsetPoint, adjacentPoint, isSource) {\n    var decEle = new PathElement();\n    updateDecoratorElement(obj, decEle, offsetPoint, adjacentPoint, isSource);\n    return decEle;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation object.\n * @param {PointModel[]} pts - Specified the annotation point model array.\n * @returns {PointModel[]} - Returns the annotation point model array.\n */\nexport function clipDecorators(connector, pts) {\n    pts[0] = clipDecorator(connector, pts, true);\n    pts[pts.length - 1] = clipDecorator(connector, pts, false);\n    return pts;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel[]} points - Specified the annotation offset point.\n * @param {boolean} isSource - Specified the is source value or not.\n * @returns {PointModel} - Returns the annotation point model.\n */\nexport function clipDecorator(connector, points, isSource) {\n    var point = { x: 0, y: 0 };\n    var start = { x: 0, y: 0 };\n    var end = { x: 0, y: 0 };\n    var length = points.length;\n    start = !isSource ? points[length - 1] : points[0];\n    end = !isSource ? points[length - 2] : points[1];\n    var len = Point.distancePoints(start, end);\n    len = (len === 0) ? 1 : len;\n    var width = connector.thickness;\n    point.x = (Math.round(start.x + width * (end.x - start.x) / len));\n    point.y = (Math.round(start.y + width * (end.y - start.y) / len));\n    var strokeWidth = 1;\n    point = Point.adjustPoint(point, end, true, (strokeWidth / 2));\n    return point;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\n// eslint-disable-next-line max-len\nexport function initDistanceLabel(obj, points, measure, pdfviewer) {\n    var labels = [];\n    var angle = Point.findAngle(points[0], points[1]);\n    var textele = textElement(obj, angle);\n    if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n        textele.content = obj.notes;\n    }\n    else {\n        textele.content = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n    }\n    textele.rotateValue = { y: -10, angle: angle };\n    if (obj.enableShapeLabel === true) {\n        textele.style.strokeColor = obj.labelBorderColor;\n        textele.style.fill = obj.labelFillColor;\n        textele.style.fontSize = obj.fontSize;\n        textele.style.color = obj.fontColor;\n        textele.style.fontFamily = obj.fontFamily;\n    }\n    labels.push(textele);\n    return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the distance value.\n */\nexport function updateDistanceLabel(obj, points, measure) {\n    var distance;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_1 = obj.wrapper.children[i];\n        if (textElement_1 && !isNullOrUndefined(textElement_1.content)) {\n            distance = measure.setConversion(findPointsLength([points[0], points[1]]) * measure.pixelToPointFactor, obj);\n            textElement_1.content = distance;\n            textElement_1.childNodes[0].text = textElement_1.content;\n            textElement_1.refreshTextElement();\n        }\n    }\n    return distance;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the radius label value.\n */\nexport function updateRadiusLabel(obj, measure) {\n    var radius;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_2 = obj.wrapper.children[i];\n        if (textElement_2 && !isNullOrUndefined(textElement_2.content)) {\n            radius = measure.setConversion((obj.bounds.width / 2) * measure.pixelToPointFactor, obj);\n            textElement_2.content = radius;\n            if (textElement_2.childNodes.length === 2) {\n                textElement_2.childNodes[0].text = radius;\n                textElement_2.childNodes.splice(textElement_2.childNodes.length - 1, 1);\n            }\n            else {\n                textElement_2.childNodes[0].text = radius;\n            }\n            textElement_2.refreshTextElement();\n        }\n    }\n    return radius;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @param {PdfViewer} pdfviewer - Specified the pdfviewer element.\n * @hidden\n * @returns {TextElement[]} - Returns the text element collections.\n */\n// eslint-disable-next-line max-len\nexport function initPerimeterLabel(obj, points, measure, pdfviewer) {\n    var labels = [];\n    var angle = Point.findAngle(points[0], points[1]);\n    var textele = textElement(obj, angle);\n    if (!pdfviewer.enableImportAnnotationMeasurement && obj.notes && obj.notes !== '') {\n        textele.content = obj.notes;\n    }\n    else {\n        textele.content = measure.calculatePerimeter(obj);\n    }\n    if (obj.enableShapeLabel === true) {\n        textele.style.strokeColor = obj.labelBorderColor;\n        textele.style.fill = obj.labelFillColor;\n        textele.style.fontSize = obj.fontSize;\n        textele.style.color = obj.fontColor;\n        textele.style.fontFamily = obj.fontFamily;\n    }\n    textele.rotateValue = { y: -10, angle: angle };\n    labels.push(textele);\n    return labels;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotation point model array.\n * @param {MeasureAnnotation} measure - Specified the measure annotation object.\n * @hidden\n * @returns {string} - Returns the perimeter label value.\n */\nexport function updatePerimeterLabel(obj, points, measure) {\n    var perimeter;\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_3 = obj.wrapper.children[i];\n        if (textElement_3 && !isNullOrUndefined(textElement_3.content)) {\n            perimeter = measure.calculatePerimeter(obj);\n            textElement_3.content = perimeter;\n            textElement_3.childNodes[0].text = textElement_3.content;\n            textElement_3.refreshTextElement();\n        }\n    }\n    return perimeter;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\nexport function removePerimeterLabel(obj) {\n    for (var i = 0; i < obj.wrapper.children.length; i++) {\n        var textElement_4 = obj.wrapper.children[i];\n        if (textElement_4 && !isNullOrUndefined(textElement_4.content)) {\n            obj.wrapper.children.splice(i, 1);\n        }\n    }\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @hidden\n * @returns {void}\n */\nexport function updateCalibrateLabel(obj) {\n    if (obj.wrapper && obj.wrapper.children) {\n        for (var i = 0; i < obj.wrapper.children.length; i++) {\n            var textElement_5 = obj.wrapper.children[i];\n            if (textElement_5 && !isNullOrUndefined(textElement_5.content)) {\n                textElement_5.content = obj.notes;\n                textElement_5.childNodes[0].text = textElement_5.content;\n                textElement_5.refreshTextElement();\n            }\n        }\n    }\n}\n/**\n * Used to find the path for polygon shapes\n *\n * @param {PointModel[]} collection - Specified the polygon annotaion points collection.\n * @hidden\n * @returns {string} - Returns the polygon annotation path.\n */\nexport function getPolygonPath(collection) {\n    var path = '';\n    var seg;\n    path = 'M' + collection[0].x + ' ' + collection[0].y;\n    var i;\n    for (i = 1; i < collection.length; i++) {\n        seg = collection[i];\n        path += 'L' + seg.x + ' ' + seg.y;\n    }\n    path += 'Z';\n    return path;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {number} angle - Specified the annotaion rotation angle.\n * @hidden\n * @returns {TextElement} - Returns the annotation text element.\n */\nexport function textElement(obj, angle) {\n    var textele = new TextElement();\n    setElementStype(obj, textele);\n    textele.style.fill = 'transparent';\n    textele.id = randomId();\n    textele.horizontalAlignment = 'Center';\n    textele.rotateValue = { y: 10, angle: angle };\n    textele.verticalAlignment = 'Top';\n    textele.relativeMode = 'Object';\n    textele.setOffsetWithRespectToBounds(.5, .5, 'Absolute');\n    // eslint-disable-next-line\n    textele.offsetX;\n    textele.style.textWrapping = 'NoWrap';\n    return textele;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel[]} points - Specified the annotaion leader points.\n * @hidden\n * @returns {PathElement[]} - Returns the annotation path elements.\n */\nexport function initLeaders(obj, points) {\n    var leaders = [];\n    var leader = initLeader(obj, points[0], points[1]);\n    leaders.push(leader);\n    leader = initLeader(obj, points[1], points[0], true);\n    leaders.push(leader);\n    return leaders;\n}\n/**\n * @param {PdfAnnotationBaseModel} obj - Specified the annotation object.\n * @param {PointModel} point1 - Specified the annotaion leader point1.\n * @param {PointModel} point2 - Specified the annotaion leader point2.\n * @param {boolean} isSecondLeader - Specified the is second leader or not.\n * @hidden\n * @returns {PathElement} - Returns the annotation path element.\n */\nexport function initLeader(obj, point1, point2, isSecondLeader) {\n    var element = new PathElement();\n    element.offsetX = point1.x;\n    element.offsetY = point1.y;\n    var angle = Point.findAngle(point1, point2);\n    var center = { x: (point1.x + point2.x) / 2, y: (point1.y + point2.y) / 2 };\n    var matrix = identityMatrix();\n    rotateMatrix(matrix, 0 - angle, center.x, center.y);\n    var rotatedPoint = transformPointByMatrix(matrix, point1);\n    var newPoint1 = { x: rotatedPoint.x, y: rotatedPoint.y - obj.leaderHeight };\n    matrix = identityMatrix();\n    rotateMatrix(matrix, angle, element.offsetX, element.offsetY);\n    rotatedPoint = transformPointByMatrix(matrix, newPoint1);\n    var finalPoint = { x: point1.x, y: point1.y };\n    element.offsetX = finalPoint.x;\n    element.offsetY = finalPoint.y;\n    element.transform = RotateTransform.Self;\n    var getPath = 'M' + point1.x + ',' + point1.y + ',L' + rotatedPoint.x + ',' + rotatedPoint.y + 'Z';\n    var size = new Size(0, obj.leaderHeight);\n    element.pivot.x = .5;\n    if (isSecondLeader) {\n        element.id = 'leader2_' + randomId();\n        element.pivot.y = 0;\n    }\n    else {\n        element.id = 'leader1_' + randomId();\n        element.pivot.y = 1;\n    }\n    setElementStype(obj, element);\n    element.rotateAngle = angle;\n    element.data = getPath;\n    element.canMeasurePath = true;\n    element.width = size.width;\n    element.height = size.height;\n    return element;\n}\n/**\n * @private\n * @param {PdfAnnotationBaseModel} connector - Specified the annotation connector object.\n * @param {PointModel} reference - Specified the pointer reference value.\n * @returns {boolean} - Returns true or false.\n */\nexport function isPointOverConnector(connector, reference) {\n    var vertexPoints = connector.vertexPoints;\n    if (!isNullOrUndefined(vertexPoints)) {\n        for (var i = 0; i < vertexPoints.length - 1; i++) {\n            var start = vertexPoints[i];\n            var end = vertexPoints[i + 1];\n            var rect = Rect.toBounds([start, end]);\n            rect.Inflate(10);\n            if (rect.containsPoint(reference)) {\n                var intersectinPt = findNearestPoint(reference, start, end);\n                var segment1 = { x1: start.x, x2: end.x, y1: start.y, y2: end.y };\n                var segment2 = { x1: reference.x, x2: intersectinPt.x, y1: reference.y, y2: intersectinPt.y };\n                var intersectDetails = intersect3(segment1, segment2);\n                if (intersectDetails.enabled) {\n                    var distance = Point.findLength(reference, intersectDetails.intersectPt);\n                    if (Math.abs(distance) < 10) {\n                        return true;\n                    }\n                }\n                else {\n                    var rect_1 = Rect.toBounds([reference, reference]);\n                    rect_1.Inflate(3);\n                    if (rect_1.containsPoint(start) || rect_1.containsPoint(end)) {\n                        return true;\n                    }\n                }\n                if (Point.equals(reference, intersectinPt)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n/**\n * @param {PointModel} reference - Specified the pointer reference value.\n * @param {PointModel} start - Specified the pointer start value.\n * @param {PointModel} end - Specified the pointer end value.\n * @private\n * @returns {PointModel} - Returns annotation point model.\n */\nexport function findNearestPoint(reference, start, end) {\n    var shortestPoint;\n    var shortest = Point.findLength(start, reference);\n    var shortest1 = Point.findLength(end, reference);\n    if (shortest > shortest1) {\n        shortestPoint = end;\n    }\n    else {\n        shortestPoint = start;\n    }\n    var angleBWStAndEnd = Point.findAngle(start, end);\n    var angleBWStAndRef = Point.findAngle(shortestPoint, reference);\n    var r = Point.findLength(shortestPoint, reference);\n    var vaAngle = angleBWStAndRef + ((angleBWStAndEnd - angleBWStAndRef) * 2);\n    return {\n        x: (shortestPoint.x + r * Math.cos(vaAngle * Math.PI / 180)),\n        y: (shortestPoint.y + r * Math.sin(vaAngle * Math.PI / 180))\n    };\n}\n/**\n * @param {DecoratorShapes} shape - Specified the annotation decorator shapes.\n * @hidden\n * @returns {string} - Returns the annotation decorator shape value.\n */\nexport function getDecoratorShape(shape) {\n    // eslint-disable-next-line\n    return decoratorShapes[shape];\n}\nvar decoratorShapes = {\n    'OpenArrow': 'M15.9,23 L5,16 L15.9,9 L17,10.7 L8.7,16 L17,21.3Z',\n    'Square': 'M0,0 L10,0 L10,10 L0,10 z',\n    'Fletch': 'M14.8,10c0,0-3.5,6,0.2,12c0,0-2.5-6-10.9-6C4.1,16,11.3,16,14.8,10z',\n    'OpenFetch': 'M6,17c-0.6,0-1-0.4-1-1s0.4-1,1-1c10.9,0,11-5,11-5' +\n        'c0-0.6,0.4-1,1-1s1,0.4,1,1C19,10.3,18.9,17,6,17C6,17,6,17,6,17z ' +\n        'M18,23c-0.5,0-1-0.4-1-1c0-0.2-0.3-5-11-5c-0.6,0-1-0.5-1-1s0.4-1,1-1c0,0,0,0,0,0' +\n        'c12.9,0,13,6.7,13,7    C19,22.6,18.6,23,18,23z',\n    'IndentedArrow': 'M17,10c0,0-4.5,5.5,0,12L5,16L17,10z',\n    'OutdentedArrow': 'M14.6,10c0,0,5.4,6,0,12L5,16L14.6,10z',\n    'DoubleArrow': 'M19,10 L19,22 L13,16Z M12,10 L12,22 L6,16Z',\n    'Arrow': 'M15,10 L15,22 L5,16Z',\n    'Diamond': 'M12,23l-7-7l7-7l6.9,7L12,23z',\n    'Circle': 'M0,50 A50,50,0 1 1 100,50 A50,50,0 1 1 0,50 Z',\n    'Butt': 'M0,0 L0,90'\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}